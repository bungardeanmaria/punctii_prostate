<!doctype html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<title>Template 2 – Fragmente prostată</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bd:#e5e7eb; --muted:#64748b; --bg:#ffffff; }
  html, body { height:100%; }
  body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#f8fafc; color:#0f172a; }
  header { position:sticky; top:0; background:#ffffffcc; backdrop-filter:saturate(1.1) blur(6px);
           border-bottom:1px solid var(--bd); padding:10px 16px; z-index:10; }
  header h1 { margin:0; font-size:18px; }
  main { padding:16px; display:grid; gap:16px; max-width:1200px; margin:0 auto; }
  .row { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
  @media (max-width: 900px) { .row { grid-template-columns: 1fr; } }
  .card { border:1px solid var(--bd); border-radius:14px; padding:14px; background:var(--bg); }
  h2 { margin:0 0 8px; font-size:18px; }
  .muted { color:var(--muted); font-size:12px; }
  .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .badge { background:#e2e8f0; border-radius:999px; padding:2px 8px; font-size:12px; }
  .right { text-align:right; }
  button { padding:10px 14px; border:0; border-radius:10px; cursor:pointer; background:#0ea5e9; color:white; }
  button.secondary { background:#64748b; }

  .table-wrap { overflow:auto; }
  table { width:100%; border-collapse:collapse; background:#fff; }
  th, td { border:1px solid var(--bd); padding:8px; text-align:left; vertical-align:middle; }
  thead th { background:#f1f5f9; position:sticky; top:0; white-space:normal; }
  input[type="number"], input[type="text"], select { width:100%; box-sizing:border-box; padding:8px; border:1px solid #cbd5e1; border-radius:8px; }
  textarea { width:100%; min-height:260px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
             border:1px solid var(--bd); border-radius:10px; padding:10px; background:#fff; }

  /* Compact table layout */
  .table-compact th, .table-compact td { padding:6px 6px; }
  .th-2 {
  display:inline-block;
  line-height:1.15;
  text-align:center;
}
  .table-compact td:nth-child(3) { white-space:normal; }
  .table-compact th:not(:nth-child(3)),
  .table-compact td:not(:nth-child(3)) { white-space:nowrap; }

  .table-compact input[type="number"],
  .table-compact input[type="text"],
  .table-compact select { padding:6px 8px; height:32px; font-size:13px; }

  td.opt { width:160px; }
  .opt-wrap { display:grid; gap:6px; }
  .opt-select { width:100%; min-width:90px; }
  .opt-tags { display:grid; grid-template-columns: repeat(2, auto); gap:4px 10px; align-items:center; }
  .opt-tags label { font-size:12px; line-height:1; white-space:nowrap; }

  @media (max-width:1100px){
    td.opt { width:130px; }
    .opt-tags { grid-template-columns:1fr 1fr; }
    .table-compact input[type="number"],
    .table-compact input[type="text"],
    .table-compact select { height:30px; font-size:12px; }
  }

  /* Disabled rows */
  tr.is-disabled { opacity:.6; }
  tr.is-disabled input, tr.is-disabled select { background:#f8fafc; color:#64748b; }
</style>
</head>
<body>
<header><h1>Template 2 – Fragmente prostatice (posterior / mijlociu / anterior)</h1></header>
<main>

  <!-- Rezultat -->
  <div class="card">
    <h2>1) Text rezultat</h2>
    <p class="muted">Se regenerează automat când editezi tabelul. Variabila JS: <code>window.finalText</code>.</p>
    <textarea id="out"></textarea>
    <div class="inline" style="margin-top:8px;">
      <button id="copy" type="button" class="secondary">Copiază</button>
      <button id="download" type="button" class="secondary">Descarcă .txt</button>
      <span id="charCount" class="badge">0 chars</span>
    </div>
  </div>

  <!-- Parenchim netumoral -->
  <div class="card">
    <h2>Parenchim netumoral</h2>
    <p class="muted">Bifează modificările care să apară în text.</p>
    <div id="parenchimWrap" class="inline" style="gap:12px;">
      <label><input type="checkbox" data-par="hgm"> hiperplazie glandulara multifocala</label>
      <label><input type="checkbox" data-par="atrof"> glande atrofice</label>
      <label><input type="checkbox" data-par="bazal"> hiperplazie de strat bazal</label>
      <label><input type="checkbox" data-par="inf_redus"> redus infiltrat inflamator limfocitar in stroma</label>
      <label><input type="checkbox" data-par="inf_mod"> moderat infiltrat inflamator limfocitar in stroma</label>
      <label><input type="checkbox" data-par="mix_mod"> moderat infiltrat inflamator mixt in stroma si intraacinar</label>
    </div>
  </div>

  <!-- Configurare & Fragmente -->
  <div class="card">
    <h2>3) Configurare & Fragmente</h2>

    <div class="inline" style="gap:12px; margin-bottom:8px;">
      <label for="fragCount"><b>Număr fragmente</b></label>
      <input id="fragCount" type="number" min="1" max="16" value="16" style="width:110px" />
      <button id="applyCount" class="secondary" type="button">Aplică</button>
      <button id="addOne" class="secondary" type="button">+1</button>
      <button id="removeOne" class="secondary" type="button">-1</button>
      <span id="totalBadge" class="badge">Total: 16</span>
      <button id="clearAll" class="secondary" type="button">Golește toate câmpurile</button>
    </div>

    <div class="inline" style="gap:12px; margin-bottom:8px;">
      <label class="inline"><input type="checkbox" id="incRight" checked> Include lob drept</label>
      <label class="inline"><input type="checkbox" id="incLeft" checked> Include lob stang</label>
      <label class="inline"><input type="checkbox" id="incNerves" checked> Include N1–N4</label>
    </div>

    <div class="table-wrap">
      <table id="tbl" class="table-compact">
        <thead>
          <tr>
            <th class="hide-on-mobile">✔</th>
            <th class="hide-on-mobile">#</th>
            <th>Nume fragment</th>
            <th id="colX"></th>
            <th id="colY"></th>
            <th id="colZ"></th>
            <th id="colA"></th>
            <th id="colB"></th>
            <th id="colC"></th>
            <th id="colD"></th>
            <th class="opt">Opt</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot>
          <tr class="tfoot-row">
            <th colspan="3" class="right">Totaluri (bifate & grupuri selectate):</th>
            <th id="sumX" title="G = ΣX">0</th>
            <th id="sumY" title="E = ΣY (mm infiltrați)">0</th>
            <th id="sumZ" title="F = round(100 × E / G)">0</th>
            <th class="right">—</th>
            <th id="sumB" title="H = total % Gleason 3 (din B/D unde A/C = 3)">0</th>
            <th class="right">—</th>
            <th id="sumD" title="I = total % Gleason 4 (din B/D unde A/C = 4)">0</th>
            <th class="right">—</th>
          </tr>
        </tfoot>
      </table>
    </div>

    <p class="muted" style="margin-top:8px;">
      Introduci: <b>X</b>, <b>Y</b>, <b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>.<br/>
      Se calculează: <b>Z</b>, <b>E</b>, <b>F</b>, <b>H</b>, <b>I</b>.<br/>
      Z (pe rând) = round(100 × Y / X). &nbsp;
      E = ΣY, G = ΣX, &nbsp; <b>F = round(100 × E / G)</b> (procent mm infiltrați din total mm fragmente).<br>
      <b>H</b> = total % Gleason 3 (din B/D unde A/C = 3), &nbsp;
      <b>I</b> = total % Gleason 4 (din B/D unde A/C = 4).
    </p>
  </div>

</main>

<script>
/* ---------- UI config with safe fallback ---------- */
const DEFAULT_UI = {
  columns: {
    X:{label:"lungime fragment",title:"lungime fragment (mm)"},
    Y:{label:"lungime tumora", title:"lungime tumora (mm)"},
    Z:{label:"% tumora",       title:"procent tumora (%)"},
    A:{label:"Gleason dominant",title:"Gleason dominant"},
    B:{label:"% Gleason dom.",  title:"procent Gleason dominant (%)"},
    C:{label:"Gleason secundar",title:"Gleason secundar"},
    D:{label:"% Gleason sec.",  title:"procent Gleason secundar (%)"}
  }
};
let UI = DEFAULT_UI;
(async () => {
  try { const r=await fetch("./config/ui.json"); if(r.ok) UI=await r.json(); } catch {}
  updateHeaders();
})();
function setCol(id,obj){ const th=document.getElementById(id); if(!th) return; th.textContent=obj.label; th.title=obj.title; }
function updateHeaders(){
  setCol("colX", UI.columns.X); setCol("colY", UI.columns.Y); setCol("colZ", UI.columns.Z);
  setCol("colA", UI.columns.A); setCol("colB", UI.columns.B); setCol("colC", UI.columns.C); setCol("colD", UI.columns.D);
}

/* ---------- Template 2 data ---------- */
const FRAGMENTS_ALL = [
  "lob drept: lateral posterior","lob drept: lateral mijlociu","lob drept: lateral anterior",
  "lob drept: medial posterior","lob drept: medial mijlociu","lob drept: medial anterior",
  "lob stang: lateral posterior","lob stang: lateral mijlociu","lob stang: lateral anterior",
  "lob stang: medial posterior","lob stang: medial mijlociu","lob stang: medial anterior",
  "N1","N2","N3","N4",
];
const RIGHT_LOCATIONS = ["lateral posterior","lateral mijlociu","lateral anterior","medial posterior","medial mijlociu","medial anterior"];
const LEFT_LOCATIONS  = ["lateral posterior","lateral mijlociu","lateral anterior","medial posterior","medial mijlociu","medial anterior"];
const MAX_FRAG=16;

/* ---------- Parenchim state ---------- */
const PARENCHIM = {
  hgm:       "hiperplazie glandulara multifocala",
  atrof:     "glande atrofice",
  bazal:     "hiperplazie de strat bazal",
  inf_redus: "redus infiltrat inflamator limfocitar in stroma",
  inf_mod:   "moderat infiltrat inflamator limfocitar in stroma",
  mix_mod:   "moderat infiltrat inflamator mixt in stroma si intraacinar"
};
let parenchimSel = { hgm:false, atrof:false, bazal:false, inf_redus:false, inf_mod:false, mix_mod:false };

/* ---------- State & DOM ---------- */
let rows=[]; let fragCount=16; let includeRight=true, includeLeft=true, includeNerves=true;
const $=(id)=>document.getElementById(id);
const tbody=$("tbody");
const sumX=$("sumX"), sumY=$("sumY"), sumZ=$("sumZ"), sumB=$("sumB"), sumD=$("sumD");
const out=$("out"), charCount=$("charCount"), totalBadge=$("totalBadge");

/* ---------- Helpers ---------- */
function newRow(name){
  return {
    name, include:true, X:"", Y:"", Z:0, A:"", B:"", C:"", D:"",
    preset:"", // "", "g3g3", "g4g4"
    tags:{ hgpin:false, hgpin_cid:false, intrad:false, pni:false }
  };
}
function ensureRowCount(n){
  n=Math.max(1,Math.min(MAX_FRAG,n));
  while(rows.length<n) rows.push(newRow(FRAGMENTS_ALL[rows.length]));
  rows.length=n; for(let i=0;i<n;i++) rows[i].name=FRAGMENTS_ALL[i];
  fragCount=n; $("fragCount").value=String(n); totalBadge.textContent=`Total: ${n}`;
}
function groupEnabled(i){ if(i<6) return includeRight; if(i<12) return includeLeft; return includeNerves; }
function includedIndices(){ return rows.map((r,i)=>({i,ok:r.include&&groupEnabled(i)})).filter(x=>x.ok).map(x=>x.i); }
function td(label,node){ const el=document.createElement("td"); el.dataset.label=label; if(node instanceof Node) el.appendChild(node); else el.textContent=node; return el; }
function setRowDisabled(tr, disabled) {
  const inputs = tr.querySelectorAll('input[type="number"], input[type="text"], select');
  inputs.forEach(el => { el.disabled = disabled; if (disabled) el.blur(); });
  tr.classList.toggle('is-disabled', disabled);
}
function effectiveIncluded(i){ return rows[i].include && groupEnabled(i); }
function refreshAllDisabledStates(){
  const trs = tbody.querySelectorAll('tr');
  trs.forEach((tr, i) => setRowDisabled(tr, !effectiveIncluded(i)));
}

/* ---------- Table ---------- */
function buildTable(){
  tbody.innerHTML = "";
  rows.forEach((r,i)=>{
    const tr = document.createElement("tr");

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = r.include;
    cb.addEventListener("change", ()=>{ r.include = cb.checked; setRowDisabled(tr, !effectiveIncluded(i)); recompute(); });
    tr.appendChild(td("✔", cb));

    tr.appendChild(td("#", i+1));
    tr.appendChild(td("Nume fragment", r.name));

    const inX = document.createElement("input"); inX.type="number"; inX.step="any"; inX.value=r.X;
    inX.addEventListener("input", ()=>{ r.X=inX.value; recompute(); });
    tr.appendChild(td(UI.columns.X.label, inX));

    const inY = document.createElement("input"); inY.type="number"; inY.step="any"; inY.value=r.Y;
    inY.addEventListener("input", ()=>{ r.Y=inY.value; recompute(); });
    tr.appendChild(td(UI.columns.Y.label, inY));

    const zCell = td(UI.columns.Z.label, r.Z || 0); zCell.className = "zcell";
    tr.appendChild(zCell);

    const inA = document.createElement("input"); inA.type="text"; inA.value=r.A;
    inA.addEventListener("input", ()=>{ r.A=inA.value; recompute(false); });
    tr.appendChild(td(UI.columns.A.label, inA));

    const inB = document.createElement("input"); inB.type="number"; inB.step="any"; inB.value=r.B;
    inB.addEventListener("input", ()=>{ r.B=inB.value; recompute(false); });
    tr.appendChild(td(UI.columns.B.label, inB));

    const inC = document.createElement("input"); inC.type="text"; inC.value=r.C;
    inC.addEventListener("input", ()=>{ r.C=inC.value; recompute(false); });
    tr.appendChild(td(UI.columns.C.label, inC));

    const inD = document.createElement("input"); inD.type="number"; inD.step="any"; inD.value=r.D;
    inD.addEventListener("input", ()=>{ r.D=inD.value; recompute(false); });
    tr.appendChild(td(UI.columns.D.label, inD));

    // Opt: preset + fraze frecvente
    const wrap = document.createElement("div"); wrap.className = "opt-wrap";
    const sel = document.createElement("select"); sel.className="opt-select";
    [["","-"],["g3g3","G3+G3"],["g4g4","G4+G4"]].forEach(([v,l])=>{ const o=document.createElement("option"); o.value=v; o.textContent=l; sel.appendChild(o); });
    sel.value = r.preset || "";
    sel.title = "Preset Gleason";
    sel.addEventListener("change", ()=>{ r.preset=sel.value; recompute(false); });
    wrap.appendChild(sel);

    const tagsRow=document.createElement("div"); tagsRow.className="opt-tags";
    const mkChk = (key, label, title) => {
      const lab=document.createElement("label"); lab.style.display="inline-flex"; lab.style.alignItems="center"; lab.style.gap="6px";
      const c=document.createElement("input"); c.type="checkbox"; c.checked=!!r.tags[key];
      c.addEventListener("change", ()=>{ r.tags[key]=c.checked; recompute(false); });
      c.title = title || label;
      lab.appendChild(c);
      const span=document.createElement("span"); span.textContent=label; span.title = title || label;
      lab.appendChild(span);
      return lab;
    };
    tagsRow.appendChild(mkChk("hgpin",     "HGPIN",     "Asociaza HGPIN."));
    tagsRow.appendChild(mkChk("hgpin_cid", "HGPIN+CID", "Asociaza HGPIN si carcinom intraductal."));
    tagsRow.appendChild(mkChk("intrad",    "Intrad.",   "cu componenta intraductala."));
    tagsRow.appendChild(mkChk("pni",       "PNI",       "Asociaza infiltrare perineurala."));
    wrap.appendChild(tagsRow);

    const optTd = td("Opt", wrap); optTd.className="opt";
    tr.appendChild(optTd);

    setRowDisabled(tr, !effectiveIncluded(i));
    tbody.appendChild(tr);
  });
}

/* ---------- Compute & text ---------- */
function recompute(updateZCells=true){
  // per-row Z
  rows.forEach(r=>{
    const X=Number(r.X), Y=Number(r.Y);
    r.Z=(isFinite(X)&&X>0&&isFinite(Y)&&Y>=0)?Math.round((Y/X)*100):0;
  });
  const idxs=includedIndices();

  // E, G, F
  const E = idxs.reduce((s,i)=> s + ((+rows[i].Y||0) > 0 ? (+rows[i].Y||0) : 0), 0);
  const G = idxs.reduce((s,i)=> s + (+rows[i].X||0), 0);
  const F = (isFinite(E) && isFinite(G) && G>0) ? Math.round((E/G)*100) : 0;

  // H (Gleason 3), I (Gleason 4) din B/D unde A/C = 3 sau 4
  const totalG3 = idxs.reduce((s,i)=>{
    const r=rows[i];
    const addDom = (String(r.A).trim()==="3") ? (+r.B||0) : 0;
    const addSec = (String(r.C).trim()==="3") ? (+r.D||0) : 0;
    return s + addDom + addSec;
  },0);
  const totalG4 = idxs.reduce((s,i)=>{
    const r=rows[i];
    const addDom = (String(r.A).trim()==="4") ? (+r.B||0) : 0;
    const addSec = (String(r.C).trim()==="4") ? (+r.D||0) : 0;
    return s + addDom + addSec;
  },0);

  // update sums
  sumX.textContent=G; // G
  sumY.textContent=E; // E
  sumZ.textContent=F; // F (procent)
  sumB.textContent=totalG3; // H
  sumD.textContent=totalG4; // I

  if(updateZCells){ [...tbody.querySelectorAll(".zcell")].forEach((c,idx)=>{ c.textContent = rows[idx].Z || 0; }); }

  // counts
  const positiveCount = idxs.filter(i => (+rows[i].Y||0) > 0).length;
  const totalCount    = idxs.length;

  window.finalText = buildReportText(E,F,G,totalG3,totalG4,positiveCount,totalCount);
  out.value = window.finalText;
  charCount.textContent = `${window.finalText.length} chars`;
}

function rowIncluded(i){ return rows[i] && rows[i].include && groupEnabled(i); }

function fragmentLineForX(prefix,start,locs,ok){
  if(!ok) return null;
  const parts=locs.map((loc,k)=>{ const idx=start+k; if(idx>=rows.length||!rowIncluded(idx)) return null; const x=rows[idx].X||"x"; return `${loc} - cu lungimea de ${x} mm`; }).filter(Boolean);
  return parts.length?`- ${prefix}: ${parts.join(", ")};`:null;
}

// ascund linia dacă Y lipsește; ascund parantezele de % dacă lipsesc; preset-urile înlocuiesc fraza Gleason; adaug tag-urile la final
function fragmentInfiltrationLines(prefix,start,locs,ok){
  if(!ok) return null;
  const lines=locs.map((loc,k)=>{
    const idx=start+k;
    if(idx>=rows.length || !rowIncluded(idx)) return null;
    const r=rows[idx];

    if(r.Y==="" || r.Y===null) return null;

    let gleasonPart="";
    if(r.preset==="g3g3"){
      gleasonPart = "cu pattern dominant si secundar Gleason 3";
    }else if(r.preset==="g4g4"){
      gleasonPart = "cu pattern dominant si secundar Gleason 4";
    }else{
      const a = r.A || "";
      const b = (r.B!=="" && r.B!=null) ? ` (${r.B}%)` : "";
      const c = r.C || "";
      const d = (r.D!=="" && r.D!=null) ? ` (${r.D}%)` : "";
      if(a || c){
        gleasonPart = `cu pattern dominant Gleason ${a}${b} si pattern secundar Gleason ${c}${d}`;
      }
    }

    const extra=[];
    if(r.tags.hgpin)     extra.push("Asociaza HGPIN.");
    if(r.tags.hgpin_cid) extra.push("Asociaza HGPIN si carcinom intraductal.");
    if(r.tags.intrad)    extra.push(", cu componenta intraductala.");
    if(r.tags.pni)       extra.push("Asociaza infiltrare perineurala.");

    const base = `${loc}: pe o lungime de ${r.Y} mm ${r.Z?`(${r.Z}%)`:``}${gleasonPart?`, ${gleasonPart}`:""}`;
    const sentence = base + ".";
    return [sentence, ...extra].join(" ");
  }).filter(Boolean);
  return lines.length?`-  ${prefix}:\n`+lines.join("\n"):null;
}

// N1–N3 se termină cu virgulă, N4 cu punct
function nervesInfiltrationLines(ok){
  if(!ok) return null;
  const lines=[];
  for(let i=12;i<16&&i<rows.length;i++){
    if(!rowIncluded(i)) continue;
    const r=rows[i];
    if(r.Y==="" || r.Y===null) continue;

    let gleasonPart="";
    if(r.preset==="g3g3"){
      gleasonPart = "cu pattern dominant si secundar Gleason 3";
    }else if(r.preset==="g4g4"){
      gleasonPart = "cu pattern dominant si secundar Gleason 4";
    }else{
      const a=r.A||""; const b=(r.B!=="" && r.B!=null)?` (${r.B}%)`:"";
      const c=r.C||""; const d=(r.D!=="" && r.D!=null)?` (${r.D}%)`:"";
      if(a || c){ gleasonPart = `cu pattern dominant Gleason ${a}${b} si pattern secundar Gleason ${c}${d}`; }
    }

    const extra=[];
    if(r.tags.hgpin)     extra.push("Asociaza HGPIN.");
    if(r.tags.hgpin_cid) extra.push("Asociaza HGPIN si carcinom intraductal.");
    if(r.tags.intrad)    extra.push(", cu componenta intraductala.");
    if(r.tags.pni)       extra.push("Asociaza infiltrare perineurala.");

    const nLabel = `N${i-11}`;
    const base = `${nLabel}: pe o lungime de ${r.Y} mm ${r.Z?`(${r.Z}%)`:``}${gleasonPart?`, ${gleasonPart}`:""}`;
    const end = (nLabel==="N4") ? "." : ",";
    lines.push([base+end, ...extra].join(" "));
  }
  return lines.join("\n");
}

function nervesXLine(ok){
  if(!ok) return null;
  const parts=[]; for(let i=12;i<16&&i<rows.length;i++){ if(!rowIncluded(i)) continue; parts.push(`N${i-11}: ${rows[i].X||"x"} mm`); }
  return parts.length?parts.join(", ")+".":null;
}

function buildParenchimText(){
  const picked = Object.keys(parenchimSel).filter(k => parenchimSel[k]).map(k => PARENCHIM[k]);
  if(!picked.length) return "Parenchimul prostatic netumoral prezinta aspecte fara particularitati notabile.";
  return "Parenchimul prostatic netumoral prezinta " + picked.join(", ") + ".";
}

function buildReportText(E,F,G,totalG3,totalG4,positiveCount,totalCount){
  const N=includedIndices().length;
  const rightX=fragmentLineForX("lob drept",0,RIGHT_LOCATIONS,includeRight);
  const leftX =fragmentLineForX("lob stang",6,LEFT_LOCATIONS,includeLeft);
  const nervesX=nervesXLine(includeNerves);

  const parts1=[`Materialul examinat este alcatuit din ${N} fragmente prostatice biopunctate astfel:`, rightX, leftX, nervesX?`\n      ${nervesX}`:null].filter(Boolean).join("\n");

  const rightInf=fragmentInfiltrationLines("lob drept",0,RIGHT_LOCATIONS,includeRight);
  const leftInf =fragmentInfiltrationLines("lob stang",6,LEFT_LOCATIONS,includeLeft);
  const nervesInf=nervesInfiltrationLines(includeNerves);
  const parts2=[`Sunt infiltrate de un adenocarcinom prostatic acinar astfel:`, rightInf, "", leftInf, "", nervesInf].filter(v=>v!==null).join("\n");

  const anyPNI = rows.some((r,i) => r.include && groupEnabled(i) && r.tags && r.tags.pni);

  const fragInfo = `${positiveCount} fragmente pozitive din totalul de ${totalCount}.`;
  const negativeBits = [
    "extensie extraprostatica",
    anyPNI ? null : "infiltrare perineurala",
    "invazie angiolimfatica"
  ].filter(Boolean).join(", ");

  const parenchimText = buildParenchimText();

  const summary =
`Sunt infiltrati in total ${E} mm (${F}%), din cei ${G} mm ai fragmentelor prelevate, ${fragInfo}

Nu se identifica aspecte de ${negativeBits} (in aceste sectiuni).

${parenchimText}

Total procent Gleason 3: ${totalG3}
Total procent Gleason 4: ${totalG4}

Diagnostic: 
Adenocarcinom prostatic acinar scor Gleason  (+), grupa de gradare  (ISUP/OMS 2022).

C 61.9   M-8140/3`;

  return `${parts1}\n\n${parts2}\n\n${summary}`;
}

/* ---------- Wire UI ---------- */
function resetAllValues(){
  rows.forEach(r=>{
    r.X=""; r.Y=""; r.Z=0; r.A=""; r.B=""; r.C=""; r.D="";
    r.preset=""; r.tags={hgpin:false,hgpin_cid:false,intrad:false,pni:false};
    r.include=true;
  });
  buildTable(); recompute();
}
$("applyCount").addEventListener("click",()=>{ const v=+$("fragCount").value; ensureRowCount(isFinite(v)?v:fragCount); buildTable(); recompute(); });
$("addOne").addEventListener("click",()=>{ ensureRowCount(fragCount+1); buildTable(); recompute(); });
$("removeOne").addEventListener("click",()=>{ ensureRowCount(fragCount-1); buildTable(); recompute(); });
$("clearAll").addEventListener("click", resetAllValues);
$("incRight").addEventListener("change", e => { includeRight = e.target.checked; refreshAllDisabledStates(); recompute(); });
$("incLeft").addEventListener("change",  e => { includeLeft  = e.target.checked; refreshAllDisabledStates(); recompute(); });
$("incNerves").addEventListener("change",e => { includeNerves= e.target.checked; refreshAllDisabledStates(); recompute(); });
$("copy").addEventListener("click", async ()=>{ try{ await navigator.clipboard.writeText(out.value); }catch{} });
$("download").addEventListener("click", ()=>{ const blob=new Blob([out.value],{type:"text/plain"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="raport_template2.txt"; a.click(); URL.revokeObjectURL(a.href); });

// Parenchim checkboxes
(function(){
  const wrap = document.getElementById("parenchimWrap");
  if(!wrap) return;
  wrap.querySelectorAll('input[type="checkbox"][data-par]').forEach(ch=>{
    ch.addEventListener("change", ()=>{
      const key = ch.dataset.par;
      parenchimSel[key] = ch.checked;
      recompute(false);
    });
  });
})();

// init
(function init(){ for(let i=0;i<16;i++) rows.push(newRow(FRAGMENTS_ALL[i])); buildTable(); recompute(); })();
</script>
</body>
</html>
