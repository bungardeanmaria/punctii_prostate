<!doctype html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<title>Template 1 – Fragmente prostată</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bd:#e5e7eb; --muted:#64748b; --bg:#ffffff; }
  html, body { height:100%; }
  body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#f8fafc; color:#0f172a; }
  header { position:sticky; top:0; background:#ffffffcc; backdrop-filter:saturate(1.1) blur(6px);
           border-bottom:1px solid var(--bd); padding:10px 16px; z-index:10; }
  header h1 { margin:0; font-size:18px; }
  main { padding:16px; display:grid; gap:16px; max-width:1200px; margin:0 auto; }
  .row { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
  @media (max-width: 900px) { .row { grid-template-columns: 1fr; } }
  .card { border:1px solid var(--bd); border-radius:14px; padding:14px; background:var(--bg); }
  h2 { margin:0 0 8px; font-size:18px; }
  .muted { color:var(--muted); font-size:12px; }
  .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .badge { background:#e2e8f0; border-radius:999px; padding:2px 8px; font-size:12px; }
  .right { text-align:right; }
  button { padding:10px 14px; border:0; border-radius:10px; cursor:pointer; background:#0ea5e9; color:white; }
  button.secondary { background:#64748b; }

  /* Table */
  .table-wrap { overflow:auto; }
  table { width:100%; border-collapse:collapse; background:#fff; }
  th, td { border:1px solid var(--bd); padding:8px; text-align:left; vertical-align:middle; }
  thead th { background:#f1f5f9; position:sticky; top:0; white-space:nowrap; } /* single row headers */
  input[type="number"], input[type="text"] { width:100%; box-sizing:border-box; padding:8px; border:1px solid #cbd5e1; border-radius:8px; }
  textarea { width:100%; min-height:260px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
             border:1px solid var(--bd); border-radius:10px; padding:10px; background:#fff; }

  /* Mobile stacked rows */
  @media (max-width: 720px) {
    table thead { display: none; }
    table, tbody, tr, td { display: block; width: 100%; }
    tr { border:1px solid var(--bd); border-radius:12px; padding:10px; margin-bottom:12px; background:#fff; }
    td { border:none; border-bottom:1px dashed #e5e7eb; }
    td:last-child { border-bottom:none; }
    td[data-label]::before {
      content: attr(data-label);
      display:block;
      font-size:12px; color:#475569; margin-bottom:4px;
    }
    .tfoot-row { display:grid; grid-template-columns: repeat(2, 1fr); gap:8px; }
    .hide-on-mobile { display:none; }
  }
  tr.is-disabled { opacity:.6; }
  tr.is-disabled input { background:#f8fafc; color:#64748b; }
</style>
</head>
<body>
<header><h1>Template 1 – Fragmente prostatice (baza / mijloc / varf)</h1></header>
<main>
  <div class="row">
    <div class="card">
      <h2>1) Text rezultat</h2>
      <p class="muted">Se regenerează automat. Variabila JS: <code>window.finalText</code>.</p>
      <textarea id="out"></textarea>
      <div class="inline" style="margin-top:8px;">
        <button id="copy" type="button" class="secondary">Copiază</button>
        <button id="download" type="button" class="secondary">Descarcă .txt</button>
        <span id="charCount" class="badge">0 chars</span>
      </div>
    </div>
  </div>
  <div class="row">
  <div class="card">
    <h2>2) Import din text</h2>
    <p class="muted">Lipește aici textul primit (format ca în textul generat). Vom detecta X / Y / A / B / C / D și completăm tabelul automat.</p>
    <textarea id="importText" placeholder="Lipește textul aici..."></textarea>
    <div class="inline" style="margin-top:8px;">
      <button id="btnParse" type="button">Pre-umple tabelul</button>
      <button id="btnClearImport" type="button" class="secondary">Golește</button>
    </div>
  </div>
</div>
  <div class="row">
    <div class="card">
      <h2>3) Configurare & Fragmente</h2>

      <div class="inline" style="gap:12px; margin-bottom:8px;">
        <label for="fragCount"><b>Număr fragmente</b></label>
        <input id="fragCount" type="number" min="1" max="16" value="16" style="width:110px" />
        <button id="applyCount" class="secondary" type="button">Aplică</button>
        <button id="addOne" class="secondary" type="button">+1</button>
        <button id="removeOne" class="secondary" type="button">-1</button>
        <span id="totalBadge" class="badge">Total: 16</span>
        <button id="clearAll" class="secondary" type="button">Golește toate câmpurile</button>
      </div>

      <div class="inline" style="gap:12px; margin-bottom:8px;">
        <label class="inline"><input type="checkbox" id="incRight" checked> Include lob drept</label>
        <label class="inline"><input type="checkbox" id="incLeft" checked> Include lob stang</label>
        <label class="inline"><input type="checkbox" id="incNerves" checked> Include N1–N4</label>
      </div>

      <div class="table-wrap">
        <table id="tbl">
          <thead>
            <tr>
              <th class="hide-on-mobile">✔</th>
              <th class="hide-on-mobile">#</th>
              <th>Nume fragment</th>
              <th id="colX"></th>
              <th id="colY"></th>
              <th id="colZ"></th>
              <th id="colA"></th>
              <th id="colB"></th>
              <th id="colC"></th>
              <th id="colD"></th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
          <tfoot>
            <tr class="tfoot-row">
              <th colspan="3" class="right">Totaluri (bifate & grupuri selectate):</th>
              <th id="sumX">0</th>
              <th id="sumY">0</th>
              <th id="sumZ">0</th>
              <th class="right">—</th>
              <th id="sumB">0</th>
              <th class="right">—</th>
              <th id="sumD">0</th>
            </tr>
          </tfoot>
        </table>
      </div>

      <p class="muted" style="margin-top:8px;">
        Z = round(100 * Y / X). &nbsp;E=ΣY, F=ΣZ, G=ΣX, H=ΣB, I=ΣD (pe elementele bifate & grupuri incluse)
      </p>
    </div>
  </div>

</main>

<script>
/* ---------- UI config (with safe fallback for file://) ---------- */
const DEFAULT_UI = {
  columns: {
    X:{label:"lungime fragment",title:"lungime fragment (mm)"},
    Y:{label:"lungime tumora", title:"lungime tumora (mm)"},
    Z:{label:"% tumora",       title:"procent tumora (%)"},
    A:{label:"Gleason dominant",title:"Gleason dominant"},
    B:{label:"% Gleason dom.",  title:"procent Gleason dominant (%)"},
    C:{label:"Gleason secundar",title:"Gleason secundar"},
    D:{label:"% Gleason sec.",  title:"procent Gleason secundar (%)"}
  }
};
let UI = DEFAULT_UI;
(async () => {
  try {
    const r = await fetch("./config/ui.json");
    if (r.ok) UI = await r.json();
  } catch {}
  updateHeaders();
})();
function setCol(id, obj){ const th=document.getElementById(id); if(!th) return; th.textContent=obj.label; th.title=obj.title; }
function updateHeaders(){
  setCol("colX", UI.columns.X); setCol("colY", UI.columns.Y); setCol("colZ", UI.columns.Z);
  setCol("colA", UI.columns.A); setCol("colB", UI.columns.B); setCol("colC", UI.columns.C); setCol("colD", UI.columns.D);
}

/* ---------- Template 1 data ---------- */
const FRAGMENTS_ALL = [
  "lob drept: lateral baza","lob drept: lateral mijloc","lob drept: lateral varf",
  "lob drept: medial baza","lob drept: medial mijloc","lob drept: medial varf",
  "lob stang: lateral baza","lob stang: lateral mijloc","lob stang: lateral varf",
  "lob stang: medial baza","lob stang: medial mijloc","lob stang: medial varf",
  "N1","N2","N3","N4",
];
const RIGHT_LOCATIONS = ["lateral baza","lateral mijloc","lateral varf","medial baza","medial mijloc","medial varf"];
const LEFT_LOCATIONS  = ["lateral baza","lateral mijloc","lateral varf","medial baza","medial mijloc","medial varf"];
const MAX_FRAG = 16;

/* ---------- State & DOM ---------- */
let rows = []; // {name, include, X,Y,Z,A,B,C,D}
let fragCount = 16;
let includeRight = true, includeLeft = true, includeNerves = true;
const $ = (id)=>document.getElementById(id);
const tbody = $("tbody");
const sumX=$("sumX"), sumY=$("sumY"), sumZ=$("sumZ"), sumB=$("sumB"), sumD=$("sumD");
const out=$("out"), charCount=$("charCount"), totalBadge=$("totalBadge");

/* ---------- Helpers ---------- */
function newRow(name){ return {name, include:true, X:"", Y:"", Z:0, A:"", B:"", C:"", D:""}; }
function ensureRowCount(n){
  n = Math.max(1, Math.min(MAX_FRAG, n));
  while(rows.length < n) rows.push(newRow(FRAGMENTS_ALL[rows.length]));
  rows.length = n;
  for(let i=0;i<n;i++) rows[i].name = FRAGMENTS_ALL[i];
  fragCount = n; $("fragCount").value = String(n); totalBadge.textContent = `Total: ${n}`;
}
function groupEnabled(i){ if(i<6) return includeRight; if(i<12) return includeLeft; return includeNerves; }
function includedIndices(){ return rows.map((r,i)=>({i,ok:r.include && groupEnabled(i)})).filter(x=>x.ok).map(x=>x.i); }

/* ---------- Table (mobile-friendly) ---------- */
function td(label, node){ const el=document.createElement("td"); el.dataset.label=label; if(node instanceof Node) el.appendChild(node); else el.textContent=node; return el; }
function setRowDisabled(tr, disabled) {
  const inputs = tr.querySelectorAll('input[type="number"], input[type="text"]');
  inputs.forEach(el => { el.disabled = disabled; if (disabled) el.blur(); });
  tr.classList.toggle('is-disabled', disabled);
}

function effectiveIncluded(i) {
  // row is editable only if row checkbox is checked AND its group is enabled
  return rows[i].include && groupEnabled(i);
}

function refreshAllDisabledStates() {
  const trs = tbody.querySelectorAll('tr');
  trs.forEach((tr, i) => {
    setRowDisabled(tr, !effectiveIncluded(i));
  });
}
function buildTable(){
  tbody.innerHTML = "";
  rows.forEach((r,i)=>{
    const tr = document.createElement("tr");

    // row checkbox
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = r.include;
    cb.addEventListener("change", ()=>{
      r.include = cb.checked;
      setRowDisabled(tr, !effectiveIncluded(i)); // <-- toggle disabled based on row+group
      recompute();
    });
    tr.appendChild(td("✔", cb));

    tr.appendChild(td("#", i+1));
    tr.appendChild(td("Nume fragment", r.name));

    const inX = document.createElement("input"); inX.type="number"; inX.step="any"; inX.value=r.X;
    inX.addEventListener("input", ()=>{ r.X=inX.value; recompute(); });
    tr.appendChild(td(UI.columns.X.label, inX));

    const inY = document.createElement("input"); inY.type="number"; inY.step="any"; inY.value=r.Y;
    inY.addEventListener("input", ()=>{ r.Y=inY.value; recompute(); });
    tr.appendChild(td(UI.columns.Y.label, inY));

    const zCell = td(UI.columns.Z.label, r.Z || 0); zCell.className = "zcell";
    tr.appendChild(zCell);

    const inA = document.createElement("input"); inA.type="text"; inA.value=r.A;
    inA.addEventListener("input", ()=>{ r.A=inA.value; recompute(false); });
    tr.appendChild(td(UI.columns.A.label, inA));

    const inB = document.createElement("input"); inB.type="number"; inB.step="any"; inB.value=r.B;
    inB.addEventListener("input", ()=>{ r.B=inB.value; recompute(false); });
    tr.appendChild(td(UI.columns.B.label, inB));

    const inC = document.createElement("input"); inC.type="text"; inC.value=r.C;
    inC.addEventListener("input", ()=>{ r.C=inC.value; recompute(false); });
    tr.appendChild(td(UI.columns.C.label, inC));

    const inD = document.createElement("input"); inD.type="number"; inD.step="any"; inD.value=r.D;
    inD.addEventListener("input", ()=>{ r.D=inD.value; recompute(false); });
    tr.appendChild(td(UI.columns.D.label, inD));

    // initial disabled state (row + group)
    setRowDisabled(tr, !effectiveIncluded(i));

    tbody.appendChild(tr);
  });
}

/* ---------- Compute & text build ---------- */
function recompute(updateZCells=true){
  rows.forEach(r=>{ const X=Number(r.X), Y=Number(r.Y); r.Z=(isFinite(X)&&X>0&&isFinite(Y)&&Y>=0)?Math.round((Y/X)*100):0; });
  const idxs=includedIndices();
  const E=idxs.reduce((s,i)=>s+(+rows[i].Y||0),0);
  const F=idxs.reduce((s,i)=>s+(+rows[i].Z||0),0);
  const G=idxs.reduce((s,i)=>s+(+rows[i].X||0),0);
  const H=idxs.reduce((s,i)=>s+(+rows[i].B||0),0);
  const I=idxs.reduce((s,i)=>s+(+rows[i].D||0),0);

  sumX.textContent=G; sumY.textContent=E; sumZ.textContent=F; sumB.textContent=H; sumD.textContent=I;
  if(updateZCells){ [...tbody.querySelectorAll(".zcell")].forEach((c,idx)=>{ c.textContent = rows[idx].Z || 0; }); }

  window.finalText = buildReportText(E,F,G,H,I);
  out.value = window.finalText;
  charCount.textContent = `${window.finalText.length} chars`;
}
function rowIncluded(i){ return rows[i] && rows[i].include && groupEnabled(i); }
function fragmentLineForX(prefix,start,locs,ok){
  if(!ok) return null;
  const parts=locs.map((loc,k)=>{ const idx=start+k; if(idx>=rows.length||!rowIncluded(idx)) return null; const x=rows[idx].X||"x"; return `${loc} - cu lungimea de ${x} mm`; }).filter(Boolean);
  return parts.length?`- ${prefix}: ${parts.join(", ")};`:null;
}
function fragmentInfiltrationLines(prefix,start,locs,ok){
  if(!ok) return null;
  const lines=locs.map((loc,k)=>{ const idx=start+k; if(idx>=rows.length||!rowIncluded(idx)) return null;
    const r=rows[idx]; const y=r.Y||"y", z=(r.Z??"z"), a=r.A||"a", b=r.B||"b", c=r.C||"c", d=r.D||"d";
    return `${loc}: pe o lungime de ${y} mm (${z}%), cu pattern dominant Gleason ${a} (${b}%) si pattern secundar Gleason ${c} (${d}%),`;
  }).filter(Boolean);
  return lines.length?`-  ${prefix}:\n`+lines.join("\n"):null;
}
function nervesXLine(ok){
  if(!ok) return null;
  const parts=[]; for(let i=12;i<16&&i<rows.length;i++){ if(!rowIncluded(i)) continue; parts.push(`N${i-11}: ${rows[i].X||"x"} mm`); }
  return parts.length?parts.join(", ")+".":null;
}
function nervesInfiltrationLines(ok){
  if(!ok) return null;
  const lines=[]; for(let i=12;i<16&&i<rows.length;i++){ if(!rowIncluded(i)) continue;
    const r=rows[i]; const y=r.Y||"y", z=(r.Z??"z"), a=r.A||"a", b=r.B||"b", c=r.C||"c", d=r.D||"d";
    lines.push(`N${i-11}: pe o lungime de ${y} mm (${z}%), cu pattern dominant Gleason ${a} (${b}%) si pattern secundar Gleason ${c} (${d}%).`);
  }
  return lines.join("\n");
}
function buildReportText(E,F,G,H,I){
  const N=includedIndices().length;
  const rightX=fragmentLineForX("lob drept",0,RIGHT_LOCATIONS,includeRight);
  const leftX =fragmentLineForX("lob stang",6,LEFT_LOCATIONS,includeLeft);
  const nervesX=nervesXLine(includeNerves);

  const parts1=[`Materialul examinat este alcatuit din ${N} fragmente prostatice biopunctate astfel:`, rightX, leftX, nervesX?`\n      ${nervesX}`:null].filter(Boolean).join("\n");
  const rightInf=fragmentInfiltrationLines("lob drept",0,RIGHT_LOCATIONS,includeRight);
  const leftInf =fragmentInfiltrationLines("lob stang",6,LEFT_LOCATIONS,includeLeft);
  const nervesInf=nervesInfiltrationLines(includeNerves);

  const parts2=[`Sunt infiltrate de un adenocarcinom prostatic acinar astfel:`, rightInf, "", leftInf, "", nervesInf].filter(v=>v!==null).join("\n");

  const summary =
`Sunt infiltrati in total ${E} mm (${F}%), din cei ${G} mm ai fragmentelor prelevate,  fragmente pozitive din totalul de .       

Nu se identifica aspecte de extensie extraprostatica, infiltrare perineurala sau invazie angiolimfatica (in aceste sectiuni).

Prezinta hiperplazie glandulara multifocala, glande atrofice si un moderat infiltrat inflamator limfocitar in stroma cu abcese glandulare focale.

Total procent pattern dominant: ${H}
Total procent pattern secundar: ${I}

Diagnostic: 
Adenocarcinom prostatic acinar scor Gleason  (+), grupa de gradare  (ISUP/OMS 2022).

C 61.9   M-8140/3`;

  return `${parts1}\n\n${parts2}\n\n${summary}`;
}

// Build a quick index: fragment name (lowercased) -> row index
function buildNameIndex() {
  const map = new Map();
  rows.forEach((r, i) => map.set(r.name.toLowerCase(), i));
  return map;
}

// Generate a regex fragment of all location tokens that appear in FRAGMENTS_ALL
// e.g. "lateral baza|lateral mijloc|lateral varf|medial baza|..." for template-1,
// or "... posterior|... mijlociu|... anterior" for template-2
function allLocationAlternation() {
  const set = new Set();
  FRAGMENTS_ALL.forEach(n => {
    const m = n.match(/: (.*)$/); // take the part after "lob (drept|stang): "
    if (m) set.add(m[1].trim());  // e.g. "lateral baza"
  });
  return Array.from(set)
    .sort((a,b)=>b.length-a.length)           // longest first, safer matching
    .map(s=>s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"))
    .join("|");
}

// Find a row index by side ("lob drept"/"lob stang") + location ("lateral baza", etc.)
function findRowIndexBySideAndLoc(side, loc) {
  const target = `${side}: ${loc}`.toLowerCase(); // exact name in FRAGMENTS_ALL
  for (let i = 0; i < rows.length; i++) {
    if (rows[i].name.toLowerCase() === target) return i;
  }
  return -1;
}

// Parse text and fill table
function parseAndFill(text) {
  if (!text || !text.trim()) return;

  // ensure we have 16 rows (or whatever user chose)
  ensureRowCount(Math.min(MAX_FRAG, FRAGMENTS_ALL.length));
  buildTable(); // to have fresh row DOM if count changed

  const nameIdx = buildNameIndex();
  const locAlt = allLocationAlternation();
  const norm = text.replace(/\r/g,"");

  // 1) X values from header lines like:
  // "- lob drept: lateral baza - cu lungimea de 12 mm, lateral mijloc - 8 mm, ..."
  // We'll capture side + each "location - cu lungimea de N mm"
  const xHeaderRe = new RegExp(
    `-\\s*(lob\\s+(drept|stang))\\s*:\\s*([\\s\\S]*?)(?:\\n|$)`,
    "gi"
  );
  let m;
  while ((m = xHeaderRe.exec(norm)) !== null) {
    const side = m[1].toLowerCase().trim(); // "lob drept" or "lob stang"
    const tail = m[3]; // the rest of the line with multiple "loc - cu lungimea de N mm"
    const perLocRe = new RegExp(
      `(?:^|,|;)\\s*(${locAlt})\\s*-\\s*(?:cu\\s+lungimea\\s+de\\s*)?(\\d+(?:[.,]\\d+)?)\\s*mm`,
      "gi"
    );
    let s;
    while ((s = perLocRe.exec(tail)) !== null) {
      const loc = s[1].toLowerCase().trim();
      const xVal = s[2].replace(",", ".");
      const idx = findRowIndexBySideAndLoc(side, loc);
      if (idx >= 0) { rows[idx].X = xVal; rows[idx].include = true; }
    }
  }

  // 2) Nerves X from lines like "N1: 4 mm", "N2- 3 mm"
  const nerveXRe = /(?:^|\n)\s*N([1-4])\s*[:\-]\s*(\d+(?:[.,]\d+)?)\s*mm/gi;
  let nx;
  while ((nx = nerveXRe.exec(norm)) !== null) {
    const n = parseInt(nx[1],10); const val = nx[2].replace(",", ".");
    const idx = 11 + n; // N1->12, etc. (0-based rows, N1 is index 12)
    if (rows[idx]) { rows[idx].X = val; rows[idx].include = true; }
  }

  // 3) Infiltration sections: keep current side from lines "-  lob drept:" / "-  lob stang:"
  let currentSide = null;
  const lines = norm.split("\n");
  const sideLineRe = /^\s*-\s*lob\s+(drept|stang)\s*:\s*$/i;
  // Lines like: "lateral baza: pe o lungime de 5 mm (42%), cu pattern dominant Gleason 3 (70%) si pattern secundar Gleason 4 (30%),"
  const infRe = new RegExp(
    `^\\s*(${locAlt})\\s*:\\s*pe\\s+o\\s+lungime\\s+de\\s*(\\d+(?:[.,]\\d+)?)\\s*mm\\s*\\((\\d+)\\s*%\\)\\s*,\\s*cu\\s*pattern\\s*dominant\\s*Gleason\\s*(\\S+)\\s*\\((\\d+)\\s*%\\)\\s*si\\s*pattern\\s*secundar\\s*Gleason\\s*(\\S+)\\s*\\((\\d+)\\s*%\\)`,
    "i"
  );

  for (const line of lines) {
    const sm = sideLineRe.exec(line);
    if (sm) { currentSide = `lob ${sm[1].toLowerCase()}`; continue; }

    const im = infRe.exec(line);
    if (im && currentSide) {
      const loc = im[1].toLowerCase().trim();
      const y = im[2].replace(",", ".");
      const z = im[3];
      const a = im[4];
      const b = im[5];
      const c = im[6];
      const d = im[7];
      const idx = findRowIndexBySideAndLoc(currentSide, loc);
      if (idx >= 0) {
        rows[idx].Y = y;
        // Z will be recomputed from X & Y anyway, but if you want to display given Z until X arrives:
        rows[idx].Z = Number(z);
        rows[idx].A = a; rows[idx].B = b; rows[idx].C = c; rows[idx].D = d;
        rows[idx].include = true;
      }
    }
  }

  // 4) Also support "N1: pe o lungime de Y mm (Z%), ..." infiltration lines for nerves:
  const nerveInfRe = /^\s*N([1-4])\s*:\s*pe\s+o\s+lungime\s+de\s*(\d+(?:[.,]\d+)?)\s*mm\s*\((\d+)\s*%\)\s*,\s*cu\s*pattern\s*dominant\s*Gleason\s*(\S+)\\s*\\((\\d+)\\s*%\\)\\s*si\\s*pattern\\s*secundar\\s*Gleason\\s*(\\S+)\\s*\\((\\d+)\\s*%\\)\\.?$/i;
  for (const line of lines) {
    const nm = nerveInfRe.exec(line);
    if (nm) {
      const n = parseInt(nm[1],10);
      const y = nm[2].replace(",", "."); const z = nm[3];
      const a = nm[4]; const b = nm[5]; const c = nm[6]; const d = nm[7];
      const idx = 11 + n;
      if (rows[idx]) {
        rows[idx].Y = y; rows[idx].Z = Number(z);
        rows[idx].A = a; rows[idx].B = b; rows[idx].C = c; rows[idx].D = d;
        rows[idx].include = true;
      }
    }
  }

  // push to UI and recompute
  buildTable();
  refreshAllDisabledStates && refreshAllDisabledStates(); // if you added disabled logic
  recompute(true);
}

// Wire buttons
document.getElementById("btnParse").addEventListener("click", ()=>{
  const txt = document.getElementById("importText").value;
  parseAndFill(txt);
});
document.getElementById("btnClearImport").addEventListener("click", ()=>{
  document.getElementById("importText").value = "";
});
/* ---------- Events & init ---------- */
function resetAllValues(){ rows.forEach(r=>{ r.X=""; r.Y=""; r.Z=0; r.A=""; r.B=""; r.C=""; r.D=""; r.include=true; }); buildTable(); recompute(); }
$("applyCount").addEventListener("click",()=>{ const v=+$("fragCount").value; ensureRowCount(isFinite(v)?v:fragCount); buildTable(); recompute(); });
$("addOne").addEventListener("click",()=>{ ensureRowCount(fragCount+1); buildTable(); recompute(); });
$("removeOne").addEventListener("click",()=>{ ensureRowCount(fragCount-1); buildTable(); recompute(); });
$("clearAll").addEventListener("click", resetAllValues);
$("incRight").addEventListener("change", e => {
  includeRight = e.target.checked;
  refreshAllDisabledStates();  // NEW
  recompute();
});
$("incLeft").addEventListener("change", e => {
  includeLeft = e.target.checked;
  refreshAllDisabledStates();  // NEW
  recompute();
});
$("incNerves").addEventListener("change", e => {
  includeNerves = e.target.checked;
  refreshAllDisabledStates();  // NEW
  recompute();
});
$("copy").addEventListener("click", async ()=>{ try{ await navigator.clipboard.writeText(out.value); }catch{} });
$("download").addEventListener("click", ()=>{ const blob=new Blob([out.value],{type:"text/plain"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="raport_template1.txt"; a.click(); URL.revokeObjectURL(a.href); });

(function init(){ for(let i=0;i<16;i++) rows.push(newRow(FRAGMENTS_ALL[i])); buildTable(); recompute(); })();
</script>
</body>
</html>
