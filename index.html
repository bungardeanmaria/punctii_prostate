<!doctype html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<title>Fragmente prostată – generator text (grupuri + per-rând include)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bd:#e5e7eb; --muted:#64748b; }
  body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin:24px; }
  h1,h2 { margin: 0 0 8px 0; }
  .muted { color: var(--muted); font-size:12px; }
  .row { display:grid; grid-template-columns: 1fr 1fr; gap:16px; margin-top:12px; }
  .card { border:1px solid var(--bd); border-radius:12px; padding:16px; background:#fff; }
  table { width:100%; border-collapse:collapse; }
  th, td { border:1px solid var(--bd); padding:6px; text-align:left; }
  th { background:#f8fafc; }
  input[type="number"], input[type="text"] { width:100%; box-sizing:border-box; padding:6px; }
  textarea { width:100%; min-height:260px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
             border:1px solid var(--bd); border-radius:8px; padding:10px; }
  .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .badge { background:#e2e8f0; border-radius:999px; padding:2px 8px; font-size:12px; }
  .right { text-align:right; }
  button { padding:10px 14px; border:0; border-radius:10px; cursor:pointer; background:#0ea5e9; color:white; }
  button.secondary { background:#64748b; }
  .switch { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid var(--bd); border-radius:999px; }
  .center { text-align:center; }
</style>
</head>
<body>
<h1>Fragmente prostatice – introducere date & generare text</h1>
<p class="muted">
  Bifează grupurile/fragmentele de inclus. Pentru fiecare fragment completezi: <b>X</b> (mm), <b>Y</b> (mm),
  <b>A</b> (pattern dominant), <b>B%</b>, <b>C</b> (pattern secundar), <b>D%</b>. <b>Z%</b> = round(100 * Y / X).
</p>

<div class="row">
  <div class="card">
    <h2>1) Configurare & Fragmente</h2>

    <div class="inline" style="gap:12px; margin-bottom:8px;">
      <label for="fragCount"><b>Număr fragmente</b></label>
      <input id="fragCount" type="number" min="1" max="16" value="16" style="width:100px" />
      <button id="applyCount" class="secondary" type="button">Aplică</button>
      <button id="addOne" class="secondary" type="button">+1</button>
      <button id="removeOne" class="secondary" type="button">-1</button>
      <span id="totalBadge" class="badge">Total: 16</span>
      <button id="clearAll" class="secondary" type="button">Golește toate câmpurile</button>
    </div>

    <div class="inline" style="gap:12px; margin-bottom:8px;">
      <label class="switch"><input type="checkbox" id="incRight" checked> Include lob drept</label>
      <label class="switch"><input type="checkbox" id="incLeft" checked> Include lob stang</label>
      <label class="switch"><input type="checkbox" id="incNerves" checked> Include N1–N4</label>
    </div>

    <div style="overflow:auto;">
      <table id="tbl">
        <thead>
          <tr>
            <th class="center">✔</th>
            <th>#</th>
            <th>Nume fragment</th>
            <th title="Lungimea fragmentului (mm)">X (mm)</th>
            <th title="Lungimea infiltrată (mm)">Y (mm)</th>
            <th>Z (%)</th>
            <th title="Pattern dominant Gleason">A</th>
            <th title="Procent dominant">% B</th>
            <th title="Pattern secundar Gleason">C</th>
            <th title="Procent secundar">% D</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot>
          <tr>
            <th colspan="3" class="right">Totaluri (pe grupurile & rândurile bifate):</th>
            <th id="sumX">0</th>
            <th id="sumY">0</th>
            <th id="sumZ">0</th>
            <th class="right">—</th>
            <th id="sumB">0</th>
            <th class="right">—</th>
            <th id="sumD">0</th>
          </tr>
        </tfoot>
      </table>
    </div>
    <p class="muted" style="margin-top:8px;">
      E = ΣY &nbsp; | &nbsp; F = ΣZ &nbsp; | &nbsp; G = ΣX &nbsp; | &nbsp; H = ΣB &nbsp; | &nbsp; I = ΣD
      (numai pe elementele bifate și din grupurile selectate)
    </p>
  </div>

  <div class="card">
    <h2>2) Text rezultat</h2>
    <p class="muted">Se regenerează automat. Variabila JS este <code>window.finalText</code>.</p>
    <textarea id="out"></textarea>
    <div class="inline" style="margin-top:8px;">
      <button id="copy" type="button" class="secondary">Copiază</button>
      <button id="download" type="button" class="secondary">Descarcă .txt</button>
      <span id="charCount" class="badge">0 chars</span>
    </div>
  </div>
</div>

<script>
/* ------------------ Config / Labels ------------------ */
const FRAGMENTS_ALL = [
  // lob drept (0..5)
  "lob drept: lateral baza",
  "lob drept: lateral mijloc",
  "lob drept: lateral varf",
  "lob drept: medial baza",
  "lob drept: medial mijloc",
  "lob drept: medial varf",
  // lob stang (6..11)
  "lob stang: lateral baza",
  "lob stang: lateral mijloc",
  "lob stang: lateral varf",
  "lob stang: medial baza",
  "lob stang: medial mijloc",
  "lob stang: medial varf",
  // N1–N4 (12..15)
  "N1","N2","N3","N4",
];

const RIGHT_LOCATIONS = ["lateral baza","lateral mijloc","lateral varf","medial baza","medial mijloc","medial varf"];
const LEFT_LOCATIONS  = ["lateral baza","lateral mijloc","lateral varf","medial baza","medial mijloc","medial varf"];
const MAX_FRAG = 16;

/* ------------------ State ------------------ */
let rows = [];      // array of {name, include, X,Y,Z,A,B,C,D}
let fragCount = 16; // current number
let includeRight = true;
let includeLeft  = true;
let includeNerves = true;

/* ------------------ DOM ------------------ */
const $ = (id) => document.getElementById(id);
const tbody = $("tbody");
const sumX = $("sumX"), sumY = $("sumY"), sumZ = $("sumZ"), sumB = $("sumB"), sumD = $("sumD");
const out = $("out"), charCount = $("charCount"), totalBadge = $("totalBadge");

/* ------------------ Helpers ------------------ */
function newRow(name) { return { name, include: true, X:"", Y:"", Z:0, A:"", B:"", C:"", D:"" }; }

function ensureRowCount(n) {
  if (n < 1) n = 1;
  if (n > MAX_FRAG) n = MAX_FRAG;
  const current = rows.length;
  if (n > current) {
    for (let i=current; i<n; i++) rows.push(newRow(FRAGMENTS_ALL[i]));
  } else if (n < current) {
    rows.length = n;
  }
  for (let i=0; i<n; i++) rows[i].name = FRAGMENTS_ALL[i];
  fragCount = n;
  $("fragCount").value = String(n);
  totalBadge.textContent = `Total: ${n}`;
}

// group indices (bounded by current rows length)
function indicesForGroup(group) {
  const res = [];
  if (group === "right") { for (let i=0;i<6 && i<rows.length;i++) res.push(i); }
  if (group === "left")  { for (let i=6;i<12 && i<rows.length;i++) res.push(i); }
  if (group === "nerves"){ for (let i=12;i<16 && i<rows.length;i++) res.push(i); }
  return res;
}
function groupEnabled(i) {
  if (i < 6) return includeRight;
  if (i < 12) return includeLeft;
  return includeNerves;
}
function includedIndices() {
  // row must be checked and its group enabled
  return rows
    .map((r, i) => ({ i, ok: r.include && groupEnabled(i) }))
    .filter(x => x.ok)
    .map(x => x.i);
}

/* ------------------ Table rendering ------------------ */
function buildTable() {
  tbody.innerHTML = "";
  rows.forEach((r, i) => {
    const tr = document.createElement("tr");

    // include checkbox
    const tdInc = document.createElement("td"); tdInc.className = "center";
    const cb = document.createElement("input"); cb.type = "checkbox"; cb.checked = r.include;
    cb.addEventListener("change", () => { r.include = cb.checked; recompute(); });
    tdInc.appendChild(cb); tr.appendChild(tdInc);

    // index
    const tdIdx = document.createElement("td"); tdIdx.textContent = i+1; tr.appendChild(tdIdx);

    // name
    const tdName = document.createElement("td"); tdName.textContent = r.name; tr.appendChild(tdName);

    // X
    const tdX = document.createElement("td");
    const inX = document.createElement("input"); inX.type="number"; inX.step="any"; inX.value=r.X;
    inX.addEventListener("input", ()=>{ r.X = inX.value; recompute(); });
    tdX.appendChild(inX); tr.appendChild(tdX);

    // Y
    const tdY = document.createElement("td");
    const inY = document.createElement("input"); inY.type="number"; inY.step="any"; inY.value=r.Y;
    inY.addEventListener("input", ()=>{ r.Y = inY.value; recompute(); });
    tdY.appendChild(inY); tr.appendChild(tdY);

    // Z (computed)
    const tdZ = document.createElement("td"); tdZ.textContent = r.Z || 0; tr.appendChild(tdZ);

    // A
    const tdA = document.createElement("td");
    const inA = document.createElement("input"); inA.type="text"; inA.value=r.A;
    inA.addEventListener("input", ()=>{ r.A = inA.value; recompute(false); });
    tdA.appendChild(inA); tr.appendChild(tdA);

    // B
    const tdB = document.createElement("td");
    const inB = document.createElement("input"); inB.type="number"; inB.step="any"; inB.value=r.B;
    inB.addEventListener("input", ()=>{ r.B = inB.value; recompute(false); });
    tdB.appendChild(inB); tr.appendChild(tdB);

    // C
    const tdC = document.createElement("td");
    const inC = document.createElement("input"); inC.type="text"; inC.value=r.C;
    inC.addEventListener("input", ()=>{ r.C = inC.value; recompute(false); });
    tdC.appendChild(inC); tr.appendChild(tdC);

    // D
    const tdD = document.createElement("td");
    const inD = document.createElement("input"); inD.type="number"; inD.step="any"; inD.value=r.D;
    inD.addEventListener("input", ()=>{ r.D = inD.value; recompute(false); });
    tdD.appendChild(inD); tr.appendChild(tdD);

    tbody.appendChild(tr);
  });
}

/* ------------------ Computations ------------------ */
function recompute(updateZCells = true) {
  rows.forEach(r => {
    const X = Number(r.X), Y = Number(r.Y);
    r.Z = (isFinite(X) && X>0 && isFinite(Y) && Y>=0) ? Math.round((Y/X)*100) : 0;
  });

  const idxs = includedIndices();
  const E = idxs.reduce((s,i)=> s + (Number(rows[i].Y)||0), 0);
  const F = idxs.reduce((s,i)=> s + (Number(rows[i].Z)||0), 0);
  const G = idxs.reduce((s,i)=> s + (Number(rows[i].X)||0), 0);
  const H = idxs.reduce((s,i)=> s + (Number(rows[i].B)||0), 0);
  const I = idxs.reduce((s,i)=> s + (Number(rows[i].D)||0), 0);

  sumX.textContent = G.toString();
  sumY.textContent = E.toString();
  sumZ.textContent = F.toString();
  sumB.textContent = H.toString();
  sumD.textContent = I.toString();

  if (updateZCells) {
    [...tbody.querySelectorAll("tr")].forEach((tr, idx) => {
      const zCell = tr.children[5]; // ✔, #, name, X, Y, Z, A, B, C, D
      zCell.textContent = rows[idx].Z || 0;
    });
  }

  window.finalText = buildReportText(E,F,G,H,I);
  out.value = window.finalText;
  charCount.textContent = `${window.finalText.length} chars`;
}

/* ------------------ Text building with toggles + per-row include ------------------ */
function rowIncluded(i) { return rows[i] && rows[i].include && groupEnabled(i); }

function fragmentLineForX(prefix, startIdx, locations, includeGroup) {
  if (!includeGroup) return null;
  const parts = locations
    .map((loc, k) => {
      const idx = startIdx + k;
      if (idx >= rows.length || !rowIncluded(idx)) return null;
      const r = rows[idx], x = r?.X || "x";
      return `${loc} - cu lungimea de ${x} mm`;
    })
    .filter(Boolean);
  if (!parts.length) return null;
  return `- ${prefix}: ${parts.join(", ")};`;
}
function fragmentInfiltrationLines(prefix, startIdx, locations, includeGroup) {
  if (!includeGroup) return null;
  const lines = locations
    .map((loc, k) => {
      const idx = startIdx + k;
      if (idx >= rows.length || !rowIncluded(idx)) return null;
      const r = rows[idx];
      const y = r?.Y || "y";
      const z = (r?.Z ?? "z");
      const a = r?.A || "a";
      const b = r?.B || "b";
      const c = r?.C || "c";
      const d = r?.D || "d";
      return `${loc}: pe o lungime de ${y} mm (${z}%), cu pattern dominant Gleason ${a} (${b}%) si pattern secundar Gleason ${c} (${d}%),`;
    })
    .filter(Boolean);
  if (!lines.length) return null;
  return `-  ${prefix}:\n` + lines.join("\n");
}
function nervesXLine(includeGroup) {
  if (!includeGroup) return null;
  const parts = [];
  for (let i=12; i<16 && i<rows.length; i++) {
    if (!rowIncluded(i)) continue;
    const label = `N${i-11}`;
    const x = rows[i].X || "x";
    parts.push(`${label}: ${x} mm`);
  }
  if (!parts.length) return null;
  return parts.join(", ") + ".";
}
function nervesInfiltrationLines(includeGroup) {
  if (!includeGroup) return null;
  const lines = [];
  for (let i=12; i<16 && i<rows.length; i++) {
    if (!rowIncluded(i)) continue;
    const label = `N${i-11}`;
    const r = rows[i];
    const y = r.Y || "y", z = (r.Z ?? "z");
    const a = r.A || "a", b = r.B || "b", c = r.C || "c", d = r.D || "d";
    lines.push(`${label}: pe o lungime de ${y} mm (${z}%), cu pattern dominant Gleason ${a} (${b}%) si pattern secundar Gleason ${c} (${d}%).`);
  }
  return lines.join("\n");
}

function buildReportText(E,F,G,H,I) {
  const N = includedIndices().length; // only included rows in enabled groups

  const rightX = fragmentLineForX("lob drept", 0, RIGHT_LOCATIONS, includeRight);
  const leftX  = fragmentLineForX("lob stang", 6, LEFT_LOCATIONS, includeLeft);
  const nervesX = nervesXLine(includeNerves);

  const parts1 = [
    `Materialul examinat este alcatuit din ${N} fragmente prostatice biopunctate astfel:`,
    rightX, leftX, nervesX ? `\n      ${nervesX}` : null
  ].filter(Boolean).join("\n");

  const rightInf = fragmentInfiltrationLines("lob drept", 0, RIGHT_LOCATIONS, includeRight);
  const leftInf  = fragmentInfiltrationLines("lob stang", 6, LEFT_LOCATIONS, includeLeft);
  const nervesInf = nervesInfiltrationLines(includeNerves);

  const parts2 = [
    `Sunt infiltrate de un adenocarcinom prostatic acinar astfel:`,
    rightInf, "", leftInf, "", nervesInf
  ].filter(s => s !== null).join("\n");

  const summary =
`Sunt infiltrati in total ${E} mm (${F}%), din cei ${G} mm ai fragmentelor prelevate,  fragmente pozitive din totalul de .       

Nu se identifica aspecte de extensie extraprostatica, infiltrare perineurala sau invazie angiolimfatica (in aceste sectiuni).

Prezinta hiperplazie glandulara multifocala, glande atrofice si un moderat infiltrat inflamator limfocitar in stroma cu abcese glandulare focale.

Total procent pattern dominant: ${H}
Total procent pattern secundar: ${I}

Diagnostic: 
Adenocarcinom prostatic acinar scor Gleason  (+), grupa de gradare  (ISUP/OMS 2022).

C 61.9   M-8140/3`;

  return `${parts1}\n\n${parts2}\n\n${summary}`.replace(/\t/g,"");
}

/* ------------------ Events & Init ------------------ */
function resetAllValues() {
  rows.forEach(r => { r.X=""; r.Y=""; r.Z=0; r.A=""; r.B=""; r.C=""; r.D=""; r.include=true; });
  buildTable(); recompute();
}

$("applyCount").addEventListener("click", () => {
  const val = Number($("fragCount").value);
  ensureRowCount(isFinite(val) ? val : fragCount);
  buildTable(); recompute();
});
$("addOne").addEventListener("click", () => { ensureRowCount(fragCount + 1); buildTable(); recompute(); });
$("removeOne").addEventListener("click", () => { ensureRowCount(fragCount - 1); buildTable(); recompute(); });
$("clearAll").addEventListener("click", resetAllValues);

$("incRight").addEventListener("change", e => { includeRight = e.target.checked; recompute(); });
$("incLeft").addEventListener("change", e => { includeLeft  = e.target.checked; recompute(); });
$("incNerves").addEventListener("change", e => { includeNerves = e.target.checked; recompute(); });

$("copy").addEventListener("click", async () => { try { await navigator.clipboard.writeText(out.value); } catch {} });
$("download").addEventListener("click", () => {
  const blob = new Blob([out.value], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "raport.txt";
  a.click();
  URL.revokeObjectURL(a.href);
});

// Boot
(function init(){
  for (let i=0;i<16;i++) rows.push(newRow(FRAGMENTS_ALL[i]));
  buildTable(); recompute();
})();
</script>
</body>
</html>
